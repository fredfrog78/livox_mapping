#include "PlyWriter.h"
#include <stdexcept> // For std::runtime_error

namespace pointcloud_accumulator {

PlyWriter::PlyWriter(const std::string& output_directory)
    : output_directory_(output_directory), total_points_(0), header_written_(false) {
    // Ensure the output directory exists or create it if it doesn't.
    // For simplicity, this example assumes the directory exists.
    // In a real application, you might want to add directory creation logic.
}

PlyWriter::~PlyWriter() {
    finalize(); // Ensure finalize is called if the object is destroyed
}

bool PlyWriter::open() {
    if (ply_file_.is_open()) {
        std::cerr << "PLY file is already open." << std::endl;
        return true; // Already open, consider it a success
    }

    // Generate timestamped filename
    auto now = std::chrono::system_clock::now();
    auto in_time_t = std::chrono::system_clock::to_time_t(now);
    std::stringstream ss;
    ss << std::put_time(std::localtime(&in_time_t), "%Y%m%d_%H%M%S");
    filepath_ = output_directory_ + "/map_" + ss.str() + ".ply";
    std::cout << "Attempting to open/create PLY file at: " << filepath_ << std::endl; // Debug output

    // Step 1: Create/truncate the file by opening for output only.
    ply_file_.open(filepath_, std::ios::binary | std::ios::out | std::ios::trunc);
    if (!ply_file_.is_open()) {
        std::cerr << "Failed to create/truncate PLY file (Step 1): " << filepath_ << std::endl;
        perror(("Error details (Step 1) for " + filepath_).c_str());
        return false;
    }
    ply_file_.close(); // Close immediately after creation/truncation.

    // Step 2: Re-open for read/write operations.
    ply_file_.open(filepath_, std::ios::binary | std::ios::out | std::ios::in);
    if (!ply_file_.is_open()) {
        std::cerr << "Failed to re-open PLY file for read/write (Step 2): " << filepath_ << std::endl;
        perror(("Error details (Step 2) for " + filepath_).c_str());
        return false;
    }

    // Write a preliminary header
    if (!writeHeader(0)) { // Write header with 0 points initially
        ply_file_.close();
        std::cerr << "Failed to write initial PLY header." << std::endl;
        return false;
    }
    header_written_ = true;
    // Important: Move the put pointer to the end of the file after writing the header,
    // so that appendPoints writes after the header.
    ply_file_.seekp(0, std::ios::end);


    std::cout << "Opened PLY file: " << filepath_ << std::endl;
    return true;
}

bool PlyWriter::writeHeader(size_t point_count) {
    if (!ply_file_.is_open()) {
        std::cerr << "Cannot write header, file is not open." << std::endl;
        return false;
    }

    // Store current position to return after writing header
    std::streampos original_pos = ply_file_.tellp();
    if (original_pos == -1 && point_count !=0) { // only print error if not initial header
        std::cerr << "Error getting stream position before writing header." << std::endl;
    }


    ply_file_.seekp(0, std::ios::beg); // Go to the beginning of the file to write/overwrite header

    std::ostringstream header;
    header << "ply\n";
    header << "format ascii 1.0\n"; // Using ASCII format for simplicity
    header << "comment Generated by PlyWriter\n";
    header << "element vertex " << point_count << "\n";
    header << "property float x\n";
    header << "property float y\n";
    header << "property float z\n";
    header << "property uchar red\n";
    header << "property uchar green\n";
    header << "property uchar blue\n";
    header << "end_header\n";

    // Pad the header with spaces to reserve enough space for future updates
    // This is a common strategy to avoid rewriting the entire file.
    // The size of the padding should be enough to accommodate the largest possible point count string.
    // For example, if you expect up to 9,999,999,999 points, "element vertex 9999999999" is 27 chars.
    // "element vertex 0" is 17 chars. So, 10 extra spaces might be enough.
    // Let's make it a fixed size for simplicity or calculate based on max_points if known.
    // For now, let's ensure the header section has a fixed size or enough padding.
    // A simple way is to fill with spaces up to a certain length.
    // This part is crucial for in-place update of the header.
    std::string header_str = header.str();
    // Make header a fixed size, e.g. 200 bytes. Pad with spaces.
    // This is a simplistic way. A more robust way would be to calculate exact padding needed.
    header_str.resize(200, ' ');
    // Ensure a newline exists after padding and before potential point data,
    // if we didn't ensure end_header is followed by a newline.
    // However, our current header string ends with "end_header\n".
    // If resizing truncates the \n, we need to add it back.
    // But resize with ' ' should fill, not truncate if original size < 200.
    // If original size > 200, it will truncate. We need to make sure 200 is enough.
    // "ply\nformat ascii 1.0\ncomment Generated by PlyWriter\nelement vertex 18446744073709551615\nproperty float x\nproperty float y\nproperty float z\nproperty uchar red\nproperty uchar green\nproperty uchar blue\nend_header\n"
    // The above with max size_t is less than 200 characters.

    ply_file_ << header_str;
    if (!ply_file_) {
        std::cerr << "Error writing header to file." << std::endl;
        return false;
    }

    if (original_pos != -1 && point_count != 0) { // If not initial header write
         ply_file_.seekp(original_pos); // Return to original position (end of file)
         if(!ply_file_){
            std::cerr << "Error seeking to original position after writing header." << std::endl;
            return false;
         }
    } else if (point_count == 0) { // After initial header, ensure pointer is at the end of header
        ply_file_.seekp(0, std::ios::end); // Move to end of what we just wrote
        // More precisely, it should be ply_file_.seekp(header_str.length(), std::ios::beg);
        // but since we opened the file fresh or are overwriting, end should be fine.
        // For initial write, this means subsequent appends write *after* this header.
    }


    return true;
}

bool PlyWriter::appendPoints(const pcl::PointCloud<pcl::PointXYZRGB>& cloud) {
    if (!ply_file_.is_open()) {
        std::cerr << "PLY file is not open. Cannot append points." << std::endl;
        return false;
    }

    if (!header_written_) {
        std::cerr << "Initial header not written. Call open() first." << std::endl;
        return false;
    }

    // Ensure the put pointer is at the end of the file.
    // This is critical if finalize() was called and then appendPoints() again (though current design doesn't support that well)
    // or if multiple PlyWriter objects are writing to the same file stream (not the case here).
    // For normal operation (open -> appendPoints... -> finalize), this seekp might be redundant
    // if open() correctly leaves the pointer at the end of the header and each appendPoints
    // leaves it at the end of the written data.
    ply_file_.seekp(0, std::ios::end);


    for (const auto& point : cloud.points) {
        // Format: X Y Z R G B
        ply_file_ << point.x << " " << point.y << " " << point.z << " "
                  << static_cast<int>(point.r) << " "  // Cast uchar to int for streaming
                  << static_cast<int>(point.g) << " "
                  << static_cast<int>(point.b) << "\n";
    }
    total_points_ += cloud.size();

    if (!ply_file_) {
        std::cerr << "Error writing points to PLY file." << std::endl;
        return false;
    }
    return true;
}

void PlyWriter::finalize() {
    if (!ply_file_.is_open()) {
        // std::cerr << "File is not open, nothing to finalize." << std::endl; // Optional: be silent if not open
        return;
    }

    if (header_written_ && total_points_ > 0) {
        // Seek back to the beginning of the file to update the header
        ply_file_.seekp(0, std::ios::beg);
        if (!writeHeader(total_points_)) {
            std::cerr << "Failed to write final header in finalize()." << std::endl;
            // Decide if we should still try to close or throw
        } else {
            std::cout << "Finalized PLY file: " << filepath_ << " with " << total_points_ << " points." << std::endl;
        }
    } else if (header_written_ && total_points_ == 0) {
        std::cout << "Finalized PLY file: " << filepath_ << " with 0 points. Header updated if necessary." << std::endl;
         // Ensure even empty files have the point count as 0.
        ply_file_.seekp(0, std::ios::beg);
        writeHeader(0);
    }


    ply_file_.close();
    header_written_ = false; // Reset for potential re-opening (though current open() doesn't support appending to existing)
    total_points_ = 0; // Reset point count

    if (ply_file_.fail() && !ply_file_.is_open()) { // Check if close caused any errors
        // Note: is_open() will be false after close().
        // fail() might be set if final flushes during close() fail.
        std::cerr << "Error occurred during file closing: " << filepath_ << std::endl;
    }
}

bool PlyWriter::isFileOpen() const {
    return ply_file_.is_open();
}

size_t PlyWriter::getTotalPoints() const {
    return total_points_;
}

} // namespace pointcloud_accumulator
